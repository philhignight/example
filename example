(function() {
    'use strict';

    // Experiment: Intercept API calls and capture template
    
    const Logger = {
        log: (category, message, data = null) => {
            const timestamp = new Date().toISOString();
            const logMessage = `[EXPERIMENT] [${timestamp}] [${category}] ${message}`;
            console.log(logMessage, data || '');
        },
        error: (category, message, error = null) => {
            const timestamp = new Date().toISOString();
            const logMessage = `[EXPERIMENT] [${timestamp}] [${category}] ERROR: ${message}`;
            console.error(logMessage, error || '');
        }
    };

    // Storage for captured template and request details
    let capturedTemplate = null;
    let capturedRequestDetails = null;
    let isTemplateCaptured = false;

    // Override fetch function
    const originalFetch = window.fetch;
    window.fetch = async function(...args) {
        const url = args[0];
        const options = args[1] || {};
        
        Logger.log('Fetch', 'Request intercepted', { 
            url: url,
            method: options.method || 'GET',
            hasBody: !!options.body
        });

        // Check if this is the API call we want to intercept
        if (typeof url === 'string' && url.includes('/api/v1/chats/new')) {
            Logger.log('Fetch', 'TARGET API CALL DETECTED!', { url });
            
            if (options.body && !isTemplateCaptured) {
                try {
                    const requestBody = JSON.parse(options.body);
                    Logger.log('Fetch', 'Original request body captured', requestBody);
                    
                    // Capture all request details
                    capturedRequestDetails = {
                        url: url,
                        method: options.method || 'GET',
                        headers: {},
                        body: requestBody
                    };
                    
                    // Extract headers
                    if (options.headers) {
                        if (options.headers instanceof Headers) {
                            // Headers object
                            for (let [key, value] of options.headers.entries()) {
                                capturedRequestDetails.headers[key] = value;
                            }
                        } else if (typeof options.headers === 'object') {
                            // Plain object
                            capturedRequestDetails.headers = { ...options.headers };
                        }
                    }
                    
                    Logger.log('Fetch', 'Complete request details captured', capturedRequestDetails);
                    
                    // Save as template and remove the fake "hi" message
                    capturedTemplate = JSON.parse(JSON.stringify(requestBody)); // Deep clone
                    
                    // Remove the fake message content but keep structure
                    if (capturedTemplate.chat && capturedTemplate.chat.messages) {
                        capturedTemplate.chat.messages.forEach(msg => {
                            if (msg.content === 'hi') {
                                Logger.log('Fetch', 'Removing fake "hi" message from template');
                                msg.content = '{{USER_MESSAGE}}'; // Placeholder
                            }
                        });
                        
                        // Also update history
                        if (capturedTemplate.chat.history && capturedTemplate.chat.history.messages) {
                            Object.values(capturedTemplate.chat.history.messages).forEach(msg => {
                                if (msg.content === 'hi') {
                                    msg.content = '{{USER_MESSAGE}}'; // Placeholder
                                }
                            });
                        }
                    }
                    
                    isTemplateCaptured = true;
                    Logger.log('Fetch', 'Template captured and cleaned', capturedTemplate);
                    
                    // Make both template and full request details globally accessible
                    window.capturedApiTemplate = capturedTemplate;
                    window.capturedRequestDetails = capturedRequestDetails;
                    Logger.log('Fetch', 'Template saved to window.capturedApiTemplate');
                    Logger.log('Fetch', 'Full request details saved to window.capturedRequestDetails');
                    
                } catch (e) {
                    Logger.error('Fetch', 'Failed to parse request body', e);
                }
            }
        }

        // Let the original request proceed
        const response = await originalFetch.apply(this, args);
        
        // Log response for the target API
        if (typeof url === 'string' && url.includes('/api/v1/chats/new')) {
            try {
                const responseClone = response.clone();
                const responseData = await responseClone.json();
                Logger.log('Fetch', 'API Response received', responseData);
            } catch (e) {
                Logger.log('Fetch', 'Could not parse API response as JSON');
            }
        }
        
        return response;
    };

    Logger.log('Init', 'Fetch function overridden, starting UI automation');

    // Function to wait for element
    async function waitForElement(selector, timeout = 30000) {
        Logger.log('Wait', `Waiting for element: ${selector}`);
        
        return new Promise((resolve, reject) => {
            const startTime = Date.now();
            
            const checkElement = () => {
                const element = document.querySelector(selector);
                const elapsed = Date.now() - startTime;
                
                if (element) {
                    Logger.log('Wait', `Element found: ${selector}`, { 
                        elapsedMs: elapsed,
                        elementType: element.tagName,
                        elementId: element.id
                    });
                    resolve(element);
                    return;
                }
                
                if (elapsed >= timeout) {
                    Logger.error('Wait', `Timeout waiting for element: ${selector}`, { 
                        elapsedMs: elapsed 
                    });
                    reject(new Error(`Timeout waiting for element: ${selector}`));
                    return;
                }
                
                setTimeout(checkElement, 100);
            };
            
            checkElement();
        });
    }

    // Main automation function
    async function runExperiment() {
        Logger.log('Experiment', 'Starting fake message automation');
        
        try {
            // Step 1: Click new chat button
            Logger.log('Experiment', 'Step 1: Looking for new chat button');
            const newChatBtn = await waitForElement('#new-chat-button');
            Logger.log('Experiment', 'Clicking new chat button');
            newChatBtn.click();
            
            // Step 2: Wait for chat input
            Logger.log('Experiment', 'Step 2: Waiting for chat input');
            const chatInput = await waitForElement('#chat-input');
            Logger.log('Experiment', 'Chat input found', {
                inputType: chatInput.tagName,
                isContentEditable: chatInput.contentEditable
            });
            
            // Step 3: Insert fake message "hi"
            Logger.log('Experiment', 'Step 3: Inserting fake message "hi"');
            chatInput.textContent = 'hi';
            Logger.log('Experiment', 'Fake message inserted');
            
            // Step 4: Wait for and click submit button
            Logger.log('Experiment', 'Step 4: Looking for submit button');
            const submitBtn = await waitForElement('#submit-prompt-btn');
            Logger.log('Experiment', 'Submit button found, clicking');
            submitBtn.click();
            Logger.log('Experiment', 'Submit button clicked - API call should be triggered');
            
            // Wait a bit for the API call to complete
            setTimeout(() => {
                if (isTemplateCaptured) {
                    Logger.log('Experiment', 'SUCCESS! Template captured successfully');
                    Logger.log('Experiment', 'Access via window.capturedApiTemplate (payload only)');
                    Logger.log('Experiment', 'Access via window.capturedRequestDetails (full request)');
                    console.log('=== CAPTURED PAYLOAD TEMPLATE ===');
                    console.log(JSON.stringify(window.capturedApiTemplate, null, 2));
                    console.log('=== FULL REQUEST DETAILS ===');
                    console.log(JSON.stringify(window.capturedRequestDetails, null, 2));
                    
                    // Start test sequence
                    startTestSequence();
                } else {
                    Logger.error('Experiment', 'Template was not captured - check if API endpoint matches');
                }
            }, 5000);
            
        } catch (error) {
            Logger.error('Experiment', 'Automation failed', error);
        }
    }

    // Function to create a real message using the template
    window.createMessageFromTemplate = function(userMessage, conversationHistory = []) {
        if (!capturedTemplate) {
            Logger.error('Template', 'No template captured yet');
            return null;
        }
        
        Logger.log('Template', 'Creating message from template', { 
            userMessage, 
            historyLength: conversationHistory.length 
        });
        
        // Clone the template
        const payload = JSON.parse(JSON.stringify(capturedTemplate));
        
        // Replace placeholder with real message
        if (payload.chat && payload.chat.messages) {
            payload.chat.messages.forEach(msg => {
                if (msg.content === '{{USER_MESSAGE}}') {
                    msg.content = userMessage;
                }
            });
            
            // Also update history
            if (payload.chat.history && payload.chat.history.messages) {
                Object.values(payload.chat.history.messages).forEach(msg => {
                    if (msg.content === '{{USER_MESSAGE}}') {
                        msg.content = userMessage;
                    }
                });
            }
        }
        
        // TODO: Add conversation history handling here if needed
        
        Logger.log('Template', 'Message created from template', payload);
        return payload;
    };

    // Function to send a message using the captured request details
    async function sendMessageWithTemplate(userMessage) {
        if (!capturedRequestDetails) {
            Logger.error('Test', 'No request details captured yet');
            return null;
        }
        
        Logger.log('Test', 'Sending custom message via API', { userMessage });
        
        // Create payload from template
        const payload = window.createMessageFromTemplate(userMessage);
        if (!payload) {
            Logger.error('Test', 'Failed to create payload from template');
            return null;
        }
        
        try {
            // Use the captured request details to make the API call
            const response = await originalFetch(capturedRequestDetails.url, {
                method: capturedRequestDetails.method,
                headers: capturedRequestDetails.headers,
                body: JSON.stringify(payload)
            });
            
            Logger.log('Test', 'API call completed', { 
                status: response.status,
                statusText: response.statusText 
            });
            
            // Try to parse response
            try {
                const responseData = await response.json();
                Logger.log('Test', 'API response data', responseData);
                return responseData;
            } catch (e) {
                Logger.log('Test', 'Could not parse response as JSON');
                const responseText = await response.text();
                Logger.log('Test', 'Response as text', responseText);
                return responseText;
            }
            
        } catch (error) {
            Logger.error('Test', 'API call failed', error);
            return null;
        }
    }

    // Test sequence function
    async function startTestSequence() {
        Logger.log('Test', 'Starting test sequence - will send 2 custom messages');
        
        // Test message 1
        Logger.log('Test', 'TEST 1: Sending first custom message');
        const response1 = await sendMessageWithTemplate('This is my first test message via direct API call');
        
        // Wait 10 seconds
        Logger.log('Test', 'Waiting 10 seconds before second test...');
        setTimeout(async () => {
            // Test message 2
            Logger.log('Test', 'TEST 2: Sending second custom message');
            const response2 = await sendMessageWithTemplate('This is my second test message, sent 10 seconds after the first one');
            
            Logger.log('Test', 'Test sequence completed!');
            Logger.log('Test', 'Check the AI interface to see if the messages appeared');
            
        }, 10000);
    }

    // Start the experiment
    Logger.log('Init', 'Experiment script loaded, starting in 2 seconds...');
    setTimeout(runExperiment, 2000);

})();
