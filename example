// Streaming AI Chat Overlay - Combined Build
// Generated on Thu Jul 31 06:50:35 PM UTC 2025

// ===== api-manager.js =====
(function() {
    'use strict';

    class StreamingAPIManager {
        constructor() {
            this.logger = window.StreamingChatLogger;
            this.config = window.StreamingChatConfig;
            this.utils = window.StreamingChatUtils;
            
            this.logger.log('StreamingAPI', 'Initializing Streaming API Manager');
            this.token = this.getAuthToken();
            this.isReady = !!this.token;
            this.activityTimeout = null;
            
            if (this.token) {
                this.logger.log('StreamingAPI', 'Auth token found', { 
                    tokenPreview: this.token.substring(0, 20) + '...' 
                });
            } else {
                this.logger.error('StreamingAPI', 'No auth token found in localStorage');
            }
        }

        getAuthToken() {
            try {
                const token = localStorage.getItem('token');
                return token;
            } catch (e) {
                this.logger.error('StreamingAPI', 'Failed to retrieve auth token', e);
                return null;
            }
        }

        checkAuthToken() {
            const currentToken = this.getAuthToken();
            if (!currentToken) {
                this.isReady = false;
                return false;
            }
            
            if (currentToken !== this.token) {
                this.logger.log('StreamingAPI', 'Auth token updated');
                this.token = currentToken;
            }
            
            this.isReady = true;
            return true;
        }

        resetActivityTimeout() {
            if (this.activityTimeout) {
                clearTimeout(this.activityTimeout);
            }
            
            this.activityTimeout = setTimeout(() => {
                this.logger.error('StreamingAPI', 'Overall timeout reached - 10 minutes of no activity');
                throw new Error('Request timeout - 10 minutes of no activity');
            }, this.config.OVERALL_TIMEOUT);
        }

        clearActivityTimeout() {
            if (this.activityTimeout) {
                clearTimeout(this.activityTimeout);
                this.activityTimeout = null;
            }
        }

        createStep1Payload(userMessage, conversationHistory = []) {
            this.logger.log('StreamingAPI', 'Creating Step 1 payload', { 
                messageLength: userMessage.length,
                historyLength: conversationHistory.length
            });

            const timestamp13 = this.utils.get13DigitTimestamp();
            const timestamp10 = this.utils.get10DigitTimestamp();
            
            // Build messages array with proper parent/child relationships
            const messages = [];
            let previousMessageId = null;
            
            // Add conversation history first
            conversationHistory.forEach((historyMsg, index) => {
                const historyMsgId = this.utils.generateUUID();
                const message = {
                    childrenIds: [],
                    content: historyMsg.content,
                    id: historyMsgId,
                    models: ["Anthropic Claude 4 Sonnet"],
                    parentId: previousMessageId,
                    role: historyMsg.role,
                    timestamp: timestamp10
                };
                
                // Update previous message's childrenIds
                if (previousMessageId) {
                    const previousMessage = messages.find(msg => msg.id === previousMessageId);
                    if (previousMessage) {
                        previousMessage.childrenIds.push(historyMsgId);
                    }
                }
                
                messages.push(message);
                previousMessageId = historyMsgId;
            });
            
            // Add current user message
            const userMessageId = this.utils.generateUUID();
            const userMessageObj = {
                childrenIds: [],
                content: userMessage,
                id: userMessageId,
                models: ["Anthropic Claude 4 Sonnet"],
                parentId: previousMessageId,
                role: "user",
                timestamp: timestamp10
            };
            
            // Update previous message's childrenIds
            if (previousMessageId) {
                const previousMessage = messages.find(msg => msg.id === previousMessageId);
                if (previousMessage) {
                    previousMessage.childrenIds.push(userMessageId);
                }
            }
            
            messages.push(userMessageObj);
            
            // Create history object with messages keyed by ID
            const historyMessages = {};
            messages.forEach(msg => {
                historyMessages[msg.id] = msg;
            });
            
            const payload = {
                chat: {
                    params: {},
                    tags: [],
                    timestamp: timestamp13,
                    title: "Chat Pending",
                    models: ["Anthropic Claude 4 Sonnet"],
                    messages: messages,
                    id: "",
                    history: {
                        currentId: userMessageId,
                        messages: historyMessages
                    }
                }
            };

            this.logger.log('StreamingAPI', 'Step 1 payload created', { 
                userMessageId, 
                timestamp13,
                totalMessages: messages.length,
                parentChildChain: messages.map(m => ({ id: m.id, parentId: m.parentId, role: m.role }))
            });
            
            return payload;
        }

        async step1CreateConversation(userMessage, conversationHistory = []) {
            this.logger.log('StreamingAPI', 'STEP 1: Creating conversation');
            
            if (!this.checkAuthToken()) {
                throw new Error('No authentication token available');
            }

            this.resetActivityTimeout();

            try {
                const payload = this.createStep1Payload(userMessage, conversationHistory);
                
                this.logger.log('StreamingAPI', 'Sending Step 1 request', { 
                    endpoint: this.config.NEW_CHAT_ENDPOINT 
                });

                const response = await fetch(this.config.NEW_CHAT_ENDPOINT, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${this.token}`
                    },
                    body: JSON.stringify(payload)
                });

                this.logger.log('StreamingAPI', 'Step 1 response received', { 
                    status: response.status,
                    statusText: response.statusText
                });

                if (response.status === 401) {
                    throw new Error('Authentication failed. Token may be expired.');
                } else if (!response.ok) {
                    throw new Error(`Step 1 failed: ${response.status} ${response.statusText}`);
                }

                const responseData = await response.json();
                this.logger.log('StreamingAPI', 'Step 1 successful', { 
                    conversationId: responseData.id,
                    userId: responseData.user_id || 'not provided'
                });

                return {
                    conversationId: responseData.id,
                    userId: responseData.user_id,
                    userMessageId: payload.chat.messages[payload.chat.messages.length - 1].id,
                    payload: payload
                };

            } catch (error) {
                this.clearActivityTimeout();
                this.logger.error('StreamingAPI', 'Step 1 failed', error);
                throw error;
            }
        }

        async step2AddAssistantSlot(conversationId, step1Payload) {
            this.logger.log('StreamingAPI', 'STEP 2: Add assistant message slot (skipping GET)', { 
                conversationId 
            });

            try {
                const assistantMessageId = this.utils.generateUUID();
                const timestamp10 = this.utils.get10DigitTimestamp();
                
                // Find the last message from Step 1 payload for parentId
                const messages = step1Payload.chat.messages || [];
                const lastMessage = messages[messages.length - 1];
                const parentId = lastMessage ? lastMessage.id : null;
                
                this.logger.log('StreamingAPI', 'Creating assistant message from Step 1 data', {
                    assistantMessageId,
                    parentId,
                    timestamp10,
                    step1MessageCount: messages.length
                });

                // Create the empty assistant message
                const assistantMessage = {
                    childrenIds: [],
                    content: "",
                    id: assistantMessageId,
                    models: ["Anthropic Claude 4 Sonnet"],
                    parentId: parentId,
                    role: "assistant",
                    timestamp: timestamp10
                };

                // Build conversation structure based on Step 1 payload
                const conversationData = {
                    archived: false,
                    chat: {
                        files: [],
                        history: {
                            currentId: assistantMessageId,
                            messages: JSON.parse(JSON.stringify(step1Payload.chat.history.messages))
                        },
                        id: conversationId,
                        messages: [...step1Payload.chat.messages],
                        models: ["Anthropic Claude 4 Sonnet"],
                        params: {},
                        tags: [],
                        timestamp: step1Payload.chat.timestamp,
                        title: "Chat Pending"
                    },
                    created_at: timestamp10,
                    folder_id: null,
                    id: conversationId,
                    meta: {},
                    pinned: false,
                    share_id: null,
                    title: "Chat Pending",
                    updated_at: timestamp10,
                    user_id: null, // Will be filled by server
                    workspace_id: null,
                    workspace_name: null,
                    workspace_type: null
                };
                
                // Add assistant message to messages array
                conversationData.chat.messages.push(assistantMessage);
                
                // Add to history.messages
                conversationData.chat.history.messages[assistantMessageId] = assistantMessage;
                
                // Update parent message's childrenIds if it exists
                if (parentId && conversationData.chat.history.messages[parentId]) {
                    if (!conversationData.chat.history.messages[parentId].childrenIds) {
                        conversationData.chat.history.messages[parentId].childrenIds = [];
                    }
                    conversationData.chat.history.messages[parentId].childrenIds.push(assistantMessageId);
                    
                    // Also update in messages array
                    const parentInMessages = conversationData.chat.messages.find(msg => msg.id === parentId);
                    if (parentInMessages) {
                        if (!parentInMessages.childrenIds) {
                            parentInMessages.childrenIds = [];
                        }
                        parentInMessages.childrenIds.push(assistantMessageId);
                    }
                }

                this.logger.log('StreamingAPI', 'Step 2: Posting conversation with assistant slot', {
                    totalMessages: conversationData.chat.messages.length,
                    assistantMessageId
                });

                // POST the conversation with assistant message slot
                const postResponse = await fetch(`${this.config.GET_CHAT_ENDPOINT}${conversationId}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${this.token}`
                    },
                    body: JSON.stringify(conversationData)
                });

                this.logger.log('StreamingAPI', 'Step 2 response received', { 
                    status: postResponse.status
                });

                if (!postResponse.ok) {
                    throw new Error(`Step 2 failed: ${postResponse.status} ${postResponse.statusText}`);
                }

                const postResponseData = await postResponse.json();
                this.logger.log('StreamingAPI', 'Step 2 complete - assistant message slot created', { 
                    assistantMessageId
                });

                return {
                    assistantMessageId: assistantMessageId,
                    conversationData: conversationData
                };

            } catch (error) {
                this.logger.error('StreamingAPI', 'Step 2 failed', error);
                throw error;
            }
        }

        createStep3Payload(conversationId, assistantMessageId, messages) {
            this.logger.log('StreamingAPI', 'Creating Step 3 payload', { 
                conversationId,
                assistantMessageId,
                messageCount: messages.length 
            });

            // Convert messages to simplified format (content + role only)
            const simplifiedMessages = messages.map(msg => ({
                content: msg.content,
                role: msg.role
            }));

            const payload = {
                background_tasks: {
                    title_generation: true,
                    tags_generation: true
                },
                chat_id: conversationId,
                features: {
                    web_search: false
                },
                id: assistantMessageId,
                messages: simplifiedMessages,
                model: "Anthropic Claude 4 Sonnet",
                params: {},
                session_id: this.config.SESSION_ID,
                stream: true
            };

            this.logger.log('StreamingAPI', 'Step 3 payload created', { 
                simplifiedMessageCount: simplifiedMessages.length 
            });

            return payload;
        }

        async step3StreamResponse(conversationId, assistantMessageId, messages, onChunk, onComplete, onError) {
            this.logger.log('StreamingAPI', 'STEP 3: Starting response stream', { 
                conversationId,
                assistantMessageId 
            });

            try {
                const payload = this.createStep3Payload(conversationId, assistantMessageId, messages);

                this.logger.log('StreamingAPI', 'Sending Step 3 request', { 
                    endpoint: this.config.COMPLETIONS_ENDPOINT 
                });

                const response = await fetch(this.config.COMPLETIONS_ENDPOINT, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${this.token}`
                    },
                    body: JSON.stringify(payload)
                });

                this.logger.log('StreamingAPI', 'Step 3 response received', { 
                    status: response.status,
                    statusText: response.statusText
                });

                if (!response.ok) {
                    throw new Error(`Step 3 failed: ${response.status} ${response.statusText}`);
                }

                if (!response.body) {
                    throw new Error('Step 3 - no response body for streaming');
                }

                this.logger.log('StreamingAPI', 'Step 3 - starting to read SSE stream');

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';
                let chunkCount = 0;

                try {
                    while (true) {
                        const { done, value } = await reader.read();
                        
                        if (done) {
                            this.logger.log('StreamingAPI', 'Step 3 - stream ended', { totalChunks: chunkCount });
                            break;
                        }

                        // Reset activity timeout on each chunk
                        this.resetActivityTimeout();

                        const chunk = decoder.decode(value, { stream: true });
                        buffer += chunk;

                        // Process complete lines
                        const lines = buffer.split('\n');
                        buffer = lines.pop() || ''; // Keep incomplete line in buffer

                        for (const line of lines) {
                            const trimmedLine = line.trim();
                            
                            if (trimmedLine.startsWith('data: ')) {
                                const jsonStr = trimmedLine.slice(6); // Remove 'data: '
                                
                                if (jsonStr === '[DONE]') {
                                    this.logger.log('StreamingAPI', 'Step 3 - received [DONE] marker');
                                    onComplete();
                                    return;
                                }

                                try {
                                    const data = JSON.parse(jsonStr);
                                    chunkCount++;
                                    
                                    this.logger.log('StreamingAPI', `Step 3 - chunk ${chunkCount}`, { 
                                        hasChoices: !!data.choices,
                                        choiceCount: data.choices?.length || 0
                                    });

                                    if (data.choices && data.choices.length > 0) {
                                        const choice = data.choices[0];
                                        
                                        if (choice.finish_reason === 'stop') {
                                            this.logger.log('StreamingAPI', 'Step 3 - received finish_reason: stop');
                                            onComplete();
                                            return;
                                        }
                                        
                                        if (choice.delta && choice.delta.content) {
                                            this.logger.log('StreamingAPI', `Step 3 - content chunk: "${choice.delta.content.substring(0, 50)}..."`);
                                            onChunk(choice.delta.content);
                                        }
                                    }
                                    
                                } catch (parseError) {
                                    this.logger.warn('StreamingAPI', 'Step 3 - failed to parse chunk', { 
                                        jsonStr: jsonStr.substring(0, 100),
                                        error: parseError.message 
                                    });
                                }
                            }
                        }
                    }

                    // If we reach here, the stream ended without [DONE] or finish_reason
                    this.logger.log('StreamingAPI', 'Step 3 - stream ended naturally');
                    onComplete();

                } catch (streamError) {
                    this.logger.error('StreamingAPI', 'Step 3 - stream reading failed', streamError);
                    onError(streamError);
                } finally {
                    try {
                        reader.releaseLock();
                    } catch (e) {
                        // Ignore lock release errors
                    }
                }

            } catch (error) {
                this.logger.error('StreamingAPI', 'Step 3 failed', error);
                onError(error);
            } finally {
                this.clearActivityTimeout();
            }
        }

        async sendMessage(userMessage, conversationHistory = [], existingConversationId = null, onChunk, onComplete, onError, onProgress = null) {
            const isNewConversation = !existingConversationId;
            
            this.logger.log('StreamingAPI', 'Starting message flow', { 
                userMessage: userMessage.substring(0, 50) + '...',
                isNewConversation,
                existingConversationId,
                historyLength: conversationHistory.length
            });

            try {
                let conversationId;
                let step2Result;
                
                if (isNewConversation) {
                    this.logger.log('StreamingAPI', 'NEW CONVERSATION: Running Step 1 + Step 2');
                    
                    // Step 1: Create conversation
                    if (onProgress) onProgress(1, 4, 'Creating conversation...');
                    const step1Result = await this.step1CreateConversation(userMessage, conversationHistory);
                    conversationId = step1Result.conversationId;
                    
                    // Step 2: Add assistant message slot (no GET needed)
                    if (onProgress) onProgress(2, 4, 'Adding assistant message slot...');
                    step2Result = await this.step2AddAssistantSlot(
                        step1Result.conversationId,
                        step1Result.payload
                    );
                } else {
                    this.logger.log('StreamingAPI', 'EXISTING CONVERSATION: Running Step 2 only');
                    conversationId = existingConversationId;
                    
                    // For existing conversations, we need to get current state and add messages
                    this.logger.log('StreamingAPI', 'Getting existing conversation for continuation');
                    const getUrl = `${this.config.GET_CHAT_ENDPOINT}${conversationId}`;
                    
                    const getResponse = await fetch(getUrl, {
                        method: 'GET',
                        headers: {
                            'Authorization': `Bearer ${this.token}`
                        }
                    });

                    if (!getResponse.ok) {
                        throw new Error(`Failed to get existing conversation: ${getResponse.status} ${getResponse.statusText}`);
                    }

                    const conversationData = await getResponse.json();
                    
                    // Create a step1-like payload from the existing conversation + new user message
                    const userMessageId = this.utils.generateUUID();
                    const timestamp10 = this.utils.get10DigitTimestamp();
                    const lastMessage = conversationData.chat.messages[conversationData.chat.messages.length - 1];

                    const newUserMessage = {
                        childrenIds: [],
                        content: userMessage,
                        id: userMessageId,
                        models: ["Anthropic Claude 4 Sonnet"],
                        parentId: lastMessage ? lastMessage.id : null,
                        role: "user",
                        timestamp: timestamp10
                    };

                    // Add user message to conversation
                    conversationData.chat.messages.push(newUserMessage);
                    conversationData.chat.history.messages[userMessageId] = newUserMessage;
                    conversationData.chat.history.currentId = userMessageId;

                    // Update parent's children
                    if (lastMessage && conversationData.chat.history.messages[lastMessage.id]) {
                        if (!conversationData.chat.history.messages[lastMessage.id].childrenIds) {
                            conversationData.chat.history.messages[lastMessage.id].childrenIds = [];
                        }
                        conversationData.chat.history.messages[lastMessage.id].childrenIds.push(userMessageId);
                    }

                    step2Result = await this.step2AddAssistantSlot(conversationId, { chat: conversationData.chat });
                }
                
                // Step 3: Stream response (same for both flows)
                const allMessages = [
                    ...conversationHistory,
                    { role: 'user', content: userMessage }
                ];
                
                if (isNewConversation) {
                    if (onProgress) onProgress(3, 4, 'Starting response stream...');
                } else {
                    if (onProgress) onProgress(2, 2, 'Starting response stream...');
                }
                
                await this.step3StreamResponse(
                    conversationId,
                    step2Result.assistantMessageId,
                    allMessages,
                    (chunk) => {
                        // Clear progress on first chunk
                        if (onProgress) onProgress(null);
                        onChunk(chunk);
                    },
                    onComplete,
                    onError
                );

                // Return conversation ID for new conversations
                return { conversationId };

            } catch (error) {
                this.logger.error('StreamingAPI', 'Complete message flow failed', error);
                onError(error);
            }
        }
    }

    window.StreamingChatAPIManager = StreamingAPIManager;

})();

// ===== chat-app.js =====
(function() {
    'use strict';

    class StreamingChatApp {
        constructor() {
            this.logger = window.StreamingChatLogger;
            this.config = window.StreamingChatConfig;
            this.utils = window.StreamingChatUtils;
            
            this.logger.log('App', 'Initializing Streaming Chat App');
            
            // Initialize managers
            this.apiManager = new window.StreamingChatAPIManager();
            this.fileSystem = new window.StreamingChatFileSystem();
            this.projectManager = new window.StreamingChatProjectManager();
            this.toolManager = new window.StreamingChatToolManager(this.fileSystem);
            this.streamingParser = new window.StreamingChatParser();
            
            // UI state
            this.elements = {};
            this.currentProject = null;
            this.currentStreamingMessage = null;
            this.lastActivityTime = Date.now();
            this.heartbeatTimer = null;
            
            // Tab management
            this.openTabs = new Map(); // tabId -> {type, projectId, filePath, content, isDirty}
            this.activeTab = 'chat';
            this.projectChats = new Map(); // projectId -> {messages: [], conversationId: null}
        }

        async init() {
            this.logger.log('App', 'Starting initialization');
            
            // Block non-app requests first
            window.StreamingChatFetchBlocker.enable();
            
            // Replace entire page with our UI
            this.container = window.StreamingChatUIBuilder.replacePageContent();
            this.bindElements();
            this.bindEvents();
            
            // Check authentication
            if (this.apiManager.isReady) {
                this.updateStatus('Ready - Streaming API', 'ready');
                this.updateUI();
                this.startHeartbeat();
                this.logger.log('App', 'Initialization complete');
            } else {
                this.updateStatus('Authentication required - No token found', 'error');
                this.updateUI();
                this.logger.error('App', 'Initialization failed - no auth token');
            }
        }

        bindElements() {
            this.elements = {
                projectDropdown: document.getElementById('project-dropdown'),
                fileExplorer: document.getElementById('file-explorer'),
                editorTabs: document.getElementById('editor-tabs'),
                editorContent: document.getElementById('editor-content'),
                messages: document.getElementById('messages-streaming'),
                userInput: document.getElementById('user-input-streaming'),
                sendBtn: document.getElementById('send-btn-streaming'),
                status: document.getElementById('status-streaming')
            };
        }

        bindEvents() {
            // Project dropdown
            this.elements.projectDropdown.addEventListener('change', (e) => {
                if (e.target.value === '__new__') {
                    this.createNewProject();
                } else if (e.target.value) {
                    this.selectProject(e.target.value);
                }
            });

            // Chat events
            this.elements.sendBtn.addEventListener('click', () => {
                this.sendMessage();
            });

            this.elements.userInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    this.sendMessage();
                }
            });

            // Tab switching
            this.elements.editorTabs.addEventListener('click', (e) => {
                const tab = e.target.closest('.editor-tab');
                if (tab) {
                    const tabId = tab.dataset.tab;
                    if (tabId) {
                        this.switchToTab(tabId);
                    }
                }
                
                const closeBtn = e.target.closest('.close-btn');
                if (closeBtn) {
                    e.stopPropagation();
                    const tab = closeBtn.closest('.editor-tab');
                    const tabId = tab.dataset.tab;
                    this.closeTab(tabId);
                }
            });

            // Global shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.ctrlKey || e.metaKey) {
                    if (e.key === 's') {
                        e.preventDefault();
                        this.saveCurrentFile();
                    } else if (e.key === 'w') {
                        e.preventDefault();
                        if (this.activeTab !== 'chat') {
                            this.closeTab(this.activeTab);
                        }
                    }
                }
            });
        }

        updateUI() {
            this.updateProjectDropdown();
            this.updateFileExplorer();
            this.updateEditorTabs();
            this.updateMessages();
        }

        updateProjectDropdown() {
            const dropdown = this.elements.projectDropdown;
            const projects = this.projectManager.listProjects();
            
            // Clear existing options except first two
            while (dropdown.children.length > 2) {
                dropdown.removeChild(dropdown.lastChild);
            }
            
            projects.forEach(project => {
                const option = document.createElement('option');
                option.value = project.id;
                option.textContent = project.name;
                if (project.id === this.currentProject) {
                    option.selected = true;
                }
                dropdown.appendChild(option);
            });
        }

        selectProject(projectId) {
            this.currentProject = projectId;
            this.toolManager.setActiveProjects([projectId]);
            
            // Initialize project chat if needed
            if (!this.projectChats.has(projectId)) {
                this.projectChats.set(projectId, {
                    messages: [],
                    conversationId: null
                });
            }
            
            this.updateUI();
            this.switchToTab('chat');
            this.updateStatus('Project selected - Ready to chat', 'ready');
        }

        updateFileExplorer() {
            const explorer = this.elements.fileExplorer;
            
            if (!this.currentProject) {
                explorer.innerHTML = '<div class="no-project">Select a project to view files</div><button class="new-file-btn" onclick="window.aiChatOverlayStreaming.createNewProject()" title="Create Project">+</button>';
                return;
            }
            
            const files = this.fileSystem.listFiles(this.currentProject);
            const fileTree = this.buildFileTree(files);
            
            explorer.innerHTML = '<button class="new-file-btn" onclick="window.aiChatOverlayStreaming.createNewFile()" title="New File">+</button>';
            const treeElement = this.renderFileTree(fileTree);
            explorer.appendChild(treeElement);
        }

        buildFileTree(files) {
            const tree = {};
            
            files.forEach(filePath => {
                const parts = filePath.split('/').filter(p => p);
                let current = tree;
                
                for (let i = 0; i < parts.length; i++) {
                    const part = parts[i];
                    const isFile = i === parts.length - 1;
                    
                    if (!current[part]) {
                        current[part] = isFile ? { __isFile: true, path: filePath } : {};
                    }
                    current = current[part];
                }
            });
            
            return tree;
        }

        renderFileTree(tree, parentPath = '') {
            const container = document.createElement('div');
            container.className = 'file-tree';
            
            Object.keys(tree).sort().forEach(name => {
                const item = tree[name];
                
                if (item.__isFile) {
                    const fileEl = document.createElement('div');
                    fileEl.className = 'file-item';
                    fileEl.textContent = name;
                    fileEl.addEventListener('click', () => {
                        this.openFile(item.path);
                    });
                    container.appendChild(fileEl);
                } else {
                    const folderEl = document.createElement('div');
                    folderEl.className = 'folder-item';
                    folderEl.innerHTML = `<span class="folder-icon">▶</span>${name}`;
                    
                    const childContainer = this.renderFileTree(item, parentPath + name + '/');
                    childContainer.style.display = 'none';
                    
                    folderEl.addEventListener('click', () => {
                        const isExpanded = folderEl.classList.contains('expanded');
                        folderEl.classList.toggle('expanded');
                        childContainer.style.display = isExpanded ? 'none' : 'block';
                    });
                    
                    container.appendChild(folderEl);
                    container.appendChild(childContainer);
                }
            });
            
            return container;
        }

        updateEditorTabs() {
            const tabsContainer = this.elements.editorTabs;
            
            // Always keep chat tab
            const chatTab = tabsContainer.querySelector('.chat-tab');
            if (chatTab) {
                chatTab.classList.toggle('active', this.activeTab === 'chat');
            }
            
            // Update file tabs
            const fileTabs = tabsContainer.querySelectorAll('.editor-tab:not(.chat-tab)');
            fileTabs.forEach(tab => {
                const tabId = tab.dataset.tab;
                if (!this.openTabs.has(tabId)) {
                    tab.remove();
                } else {
                    tab.classList.toggle('active', this.activeTab === tabId);
                }
            });
            
            // Add new file tabs
            this.openTabs.forEach((tabData, tabId) => {
                if (tabId === 'chat') return;
                
                let tab = tabsContainer.querySelector(`[data-tab="${tabId}"]`);
                if (!tab) {
                    tab = document.createElement('div');
                    tab.className = 'editor-tab';
                    tab.dataset.tab = tabId;
                    
                    const fileName = tabData.filePath.split('/').pop();
                    tab.innerHTML = `
                        <span>📄 ${fileName}</span>
                        <button class="close-btn">×</button>
                    `;
                    
                    tabsContainer.appendChild(tab);
                }
                
                tab.classList.toggle('active', this.activeTab === tabId);
            });
        }

        switchToTab(tabId) {
            this.activeTab = tabId;
            
            // Update tab visual state
            this.updateEditorTabs();
            
            // Update content
            const panes = this.elements.editorContent.querySelectorAll('.tab-pane');
            panes.forEach(pane => {
                pane.classList.remove('active');
            });
            
            if (tabId === 'chat') {
                const chatPane = this.elements.editorContent.querySelector('[data-tab="chat"]');
                if (chatPane) {
                    chatPane.classList.add('active');
                }
            } else {
                this.showFileEditor(tabId);
            }
        }

        openFile(filePath) {
            if (!this.currentProject) return;
            
            const tabId = `${this.currentProject}:${filePath}`;
            
            // Check if already open
            if (this.openTabs.has(tabId)) {
                this.switchToTab(tabId);
                return;
            }
            
            // Load file content
            const content = this.fileSystem.readFile(this.currentProject, filePath) || '';
            
            // Add to open tabs
            this.openTabs.set(tabId, {
                type: 'file',
                projectId: this.currentProject,
                filePath: filePath,
                content: content,
                isDirty: false
            });
            
            // Update UI and switch to tab
            this.updateEditorTabs();
            this.switchToTab(tabId);
        }

        showFileEditor(tabId) {
            const tabData = this.openTabs.get(tabId);
            if (!tabData) return;
            
            // Remove existing file editor pane
            const existingPane = this.elements.editorContent.querySelector('.file-editor-pane');
            if (existingPane) {
                existingPane.remove();
            }
            
            // Create file editor pane
            const pane = document.createElement('div');
            pane.className = 'tab-pane file-editor-pane active';
            pane.innerHTML = `
                <div class="file-actions">
                    <span class="file-path">${tabData.filePath}</span>
                    <button class="btn save-btn">Save</button>
                </div>
                <div class="file-editor-content">
                    <textarea class="editor-textarea" placeholder="Start typing...">${tabData.content}</textarea>
                </div>
            `;
            
            this.elements.editorContent.appendChild(pane);
            
            // Bind save button
            const saveBtn = pane.querySelector('.save-btn');
            const textarea = pane.querySelector('.editor-textarea');
            
            saveBtn.addEventListener('click', () => {
                this.saveFile(tabId);
            });
            
            textarea.addEventListener('input', () => {
                tabData.content = textarea.value;
                tabData.isDirty = true;
                // TODO: Add visual dirty indicator
            });
        }

        closeTab(tabId) {
            if (tabId === 'chat') return; // Can't close chat tab
            
            const tabData = this.openTabs.get(tabId);
            if (tabData && tabData.isDirty) {
                if (!confirm('File has unsaved changes. Close anyway?')) {
                    return;
                }
            }
            
            this.openTabs.delete(tabId);
            
            // If closing active tab, switch to chat
            if (this.activeTab === tabId) {
                this.switchToTab('chat');
            } else {
                this.updateEditorTabs();
            }
        }

        saveFile(tabId) {
            const tabData = this.openTabs.get(tabId);
            if (!tabData) return;
            
            this.fileSystem.writeFile(tabData.projectId, tabData.filePath, tabData.content);
            tabData.isDirty = false;
            
            this.updateStatus('File saved', 'success');
            setTimeout(() => {
                this.updateStatus('Ready', 'ready');
            }, 2000);
        }

        saveCurrentFile() {
            if (this.activeTab !== 'chat') {
                this.saveFile(this.activeTab);
            }
        }

        createNewProject() {
            const name = prompt('Project name:');
            if (name && name.trim()) {
                const project = this.projectManager.createProject(name.trim());
                this.updateProjectDropdown();
                this.selectProject(project.id);
            }
        }

        createNewFile() {
            if (!this.currentProject) {
                alert('Please select a project first');
                return;
            }
            
            const path = prompt('File path (e.g., /src/main.js):');
            if (path && path.trim()) {
                const filePath = path.trim();
                this.fileSystem.writeFile(this.currentProject, filePath, '');
                this.updateFileExplorer();
                this.openFile(filePath);
            }
        }

        updateMessages() {
            if (!this.currentProject) return;
            
            const projectChat = this.projectChats.get(this.currentProject);
            if (!projectChat) return;
            
            this.elements.messages.innerHTML = '';
            
            projectChat.messages.forEach(msg => {
                const messageEl = document.createElement('div');
                messageEl.className = `message ${msg.role}`;
                messageEl.textContent = msg.content;
                this.elements.messages.appendChild(messageEl);
            });
            
            this.elements.messages.scrollTop = this.elements.messages.scrollHeight;
        }

        updateStatus(message, type = 'ready') {
            this.elements.status.textContent = message;
            this.elements.status.className = `status-bar ${type}`;
        }

        createStreamingMessage() {
            const messageEl = document.createElement('div');
            messageEl.className = 'message assistant streaming';
            this.elements.messages.appendChild(messageEl);
            this.elements.messages.scrollTop = this.elements.messages.scrollHeight;
            return messageEl;
        }

        createProgressMessage(message) {
            const messageEl = document.createElement('div');
            messageEl.className = 'message progress';
            messageEl.innerHTML = `
                <div class="progress-bar-container">
                    <div class="progress-bar-fill" style="width: 0%"></div>
                </div>
            `;
            this.elements.messages.appendChild(messageEl);
            this.elements.messages.scrollTop = this.elements.messages.scrollHeight;
            return messageEl;
        }

        updateProgressMessage(message, current, total) {
            if (this.currentStreamingMessage && this.currentStreamingMessage.classList.contains('progress')) {
                const fill = this.currentStreamingMessage.querySelector('.progress-bar-fill');
                if (fill) {
                    const percentage = Math.round((current / total) * 100);
                    fill.style.width = `${percentage}%`;
                }
            }
        }

        createToolUseIndicator(toolData) {
            const indicator = document.createElement('span');
            indicator.className = 'tool-use-indicator';
            indicator.innerHTML = `
                <span class="tool-icon">🔧</span>
                <span class="tool-main">${toolData.tool_type}</span>
            `;
            
            indicator.addEventListener('click', () => {
                alert(`Tool: ${toolData.tool_type}\n\nParameters:\n${JSON.stringify(toolData, null, 2)}`);
            });
            
            return indicator;
        }

        createToolResultBubble(result) {
            const bubble = document.createElement('div');
            bubble.className = 'message tool-result';
            
            const header = document.createElement('div');
            header.className = 'tool-header';
            header.innerHTML = `
                <span class="tool-icon">⚙️</span>
                <span class="tool-title">Tool Result: ${result.tool_type}</span>
            `;
            
            const preview = document.createElement('div');
            preview.className = 'tool-preview';
            
            if (result.error) {
                preview.textContent = `Error: ${result.error}`;
            } else if (result.results && result.results.length > 0) {
                preview.textContent = `Found ${result.results.length} result(s)`;
            } else {
                preview.textContent = 'No results';
            }
            
            bubble.appendChild(header);
            bubble.appendChild(preview);
            
            bubble.addEventListener('click', () => {
                alert(`Tool Result:\n\n${JSON.stringify(result, null, 2)}`);
            });
            
            return bubble;
        }

        async sendMessage(isHeartbeat = false) {
            if (!this.currentProject) {
                if (!isHeartbeat) {
                    this.updateStatus('Please select a project first', 'error');
                }
                return;
            }

            const input = this.elements.userInput;
            const userMessage = isHeartbeat ? this.config.HEARTBEAT_MESSAGE : input.value.trim();

            if (!userMessage) {
                if (!isHeartbeat) {
                    this.updateStatus('Please enter a message', 'error');
                }
                return;
            }

            if (!isHeartbeat) {
                this.elements.sendBtn.disabled = true;
                input.disabled = true;
                input.value = '';
            }

            const projectChat = this.projectChats.get(this.currentProject);
            const existingConversationId = projectChat ? projectChat.conversationId : null;

            try {
                this.updateActivity();

                if (!isHeartbeat) {
                    // Add user message to chat
                    const userMessageEl = document.createElement('div');
                    userMessageEl.className = 'message user';
                    userMessageEl.textContent = userMessage;
                    this.elements.messages.appendChild(userMessageEl);
                    this.elements.messages.scrollTop = this.elements.messages.scrollHeight;

                    // Add to project chat history
                    if (projectChat) {
                        projectChat.messages.push({
                            role: 'user',
                            content: userMessage,
                            timestamp: Date.now()
                        });
                    }

                    // Create progress message
                    this.currentStreamingMessage = this.createProgressMessage('Starting...');
                    this.streamingParser.reset();
                }

                const result = await this.apiManager.sendMessage(
                    userMessage,
                    projectChat ? projectChat.messages.slice(0, -1) : [], // Exclude just-added user message
                    existingConversationId,
                    // onChunk
                    (chunk) => {
                        if (!isHeartbeat) {
                            const parseResult = this.streamingParser.processChunk(chunk);
                            
                            if (this.currentStreamingMessage) {
                                this.currentStreamingMessage.textContent += parseResult.displayText;
                            }
                            
                            // Add tool use indicators inline
                            parseResult.toolUses.forEach(toolUse => {
                                const indicator = this.createToolUseIndicator(toolUse.data);
                                this.currentStreamingMessage.appendChild(indicator);
                            });
                            
                            this.elements.messages.scrollTop = this.elements.messages.scrollHeight;
                            this.updateStatus('Streaming response...', 'streaming');
                        }
                    },
                    // onComplete
                    async () => {
                        if (isHeartbeat) {
                            this.logger.log('Heartbeat', 'Heartbeat completed successfully');
                        } else {
                            this.logger.log('App', 'Streaming completed');
                            
                            // Remove streaming indicator
                            if (this.currentStreamingMessage) {
                                this.currentStreamingMessage.classList.remove('streaming');
                            }
                            
                            // Get all tool uses from the complete response
                            const toolUses = this.streamingParser.getToolUses();
                            
                            if (toolUses.length > 0) {
                                this.logger.log('App', 'Executing tools', { count: toolUses.length });
                                this.updateStatus('Executing tools...', 'streaming');
                                
                                // Execute all tools
                                const toolResults = [];
                                for (const toolUse of toolUses) {
                                    try {
                                        const result = await this.toolManager.executeTool(toolUse.data);
                                        toolResults.push(result);
                                        
                                        // Create and add tool result bubble
                                        const resultBubble = this.createToolResultBubble(result);
                                        this.elements.messages.appendChild(resultBubble);
                                        this.elements.messages.scrollTop = this.elements.messages.scrollHeight;
                                    } catch (error) {
                                        this.logger.error('App', 'Tool execution failed', error);
                                        const errorBubble = this.createToolResultBubble({
                                            tool_type: toolUse.data.tool_type,
                                            error: error.message,
                                            results: []
                                        });
                                        this.elements.messages.appendChild(errorBubble);
                                    }
                                }
                                
                                this.updateStatus('Tools completed', 'success');
                                
                                // TODO: If tools were executed, continue conversation with tool results
                                // For now, just complete this turn
                            }
                            
                            // Save the complete response
                            const completeOutput = this.streamingParser.getCompleteOutput();
                            if (completeOutput && projectChat) {
                                projectChat.messages.push({
                                    role: 'assistant',
                                    content: completeOutput,
                                    timestamp: Date.now()
                                });
                            }
                            
                            this.currentStreamingMessage = null;
                            this.updateStatus('Message completed', 'success');
                        }
                    },
                    // onError
                    (error) => {
                        if (!isHeartbeat) {
                            this.logger.error('App', 'Streaming failed', error);
                            
                            // Remove streaming message on error
                            if (this.currentStreamingMessage) {
                                this.currentStreamingMessage.remove();
                                this.currentStreamingMessage = null;
                            }
                            
                            if (error.message.includes('Authentication') || error.message.includes('token')) {
                                this.updateStatus('Authentication error - Please refresh and log in', 'error');
                            } else {
                                this.updateStatus(`Error: ${error.message}`, 'error');
                            }
                        } else {
                            this.logger.error('Heartbeat', 'Heartbeat failed', error);
                        }
                    },
                    // onProgress
                    !isHeartbeat ? (current, total, message) => {
                        if (current === null) {
                            // Replace progress message with streaming message
                            if (this.currentStreamingMessage && this.currentStreamingMessage.classList.contains('progress')) {
                                this.currentStreamingMessage.remove();
                                this.currentStreamingMessage = this.createStreamingMessage();
                            }
                            this.updateStatus('Streaming response...', 'streaming');
                        } else {
                            // Update progress bar and text
                            this.updateProgressMessage(message, current, total);
                            this.elements.messages.scrollTop = this.elements.messages.scrollHeight;
                        }
                    } : null
                );
                
                // Save conversation ID for new conversations (after await completes)
                if (!isHeartbeat && result && result.conversationId && !existingConversationId && projectChat) {
                    projectChat.conversationId = result.conversationId;
                    this.logger.log('App', 'Saved new conversation ID for project', { 
                        conversationId: result.conversationId,
                        projectId: this.currentProject
                    });
                }
                
            } catch (error) {
                if (!isHeartbeat) {
                    this.logger.error('App', 'Send message failed', error);
                    this.updateStatus(`Error: ${error.message}`, 'error');
                }
            } finally {
                if (!isHeartbeat) {
                    this.elements.sendBtn.disabled = false;
                    input.disabled = false;
                    this.elements.userInput.focus();
                }
            }
        }

        updateActivity() {
            this.lastActivityTime = Date.now();
        }

        startHeartbeat() {
            this.logger.log('Heartbeat', 'Starting heartbeat system');
            
            if (this.heartbeatTimer) {
                clearInterval(this.heartbeatTimer);
            }
            
            this.heartbeatTimer = setInterval(() => {
                const timeSinceActivity = Date.now() - this.lastActivityTime;
                
                if (timeSinceActivity >= this.config.HEARTBEAT_INTERVAL) {
                    this.logger.log('Heartbeat', 'Sending heartbeat to keep session alive');
                    this.sendMessage(true);
                    this.updateActivity();
                }
            }, 10000);
        }

        stopHeartbeat() {
            if (this.heartbeatTimer) {
                clearInterval(this.heartbeatTimer);
                this.heartbeatTimer = null;
            }
        }

        close() {
            this.apiManager.clearActivityTimeout();
            this.stopHeartbeat();
            // Since we replaced the entire page, just reload to restore original
            this.logger.log('App', 'Closing - reloading page to restore original interface');
            window.location.reload();
        }
    }

    window.StreamingChatApp = StreamingChatApp;

})();

// ===== config.js =====
(function() {
    'use strict';

    window.StreamingChatConfig = {
        STORAGE_KEY: 'ai_chat_overlay_streaming_data',
        PROJECTS_KEY: 'ai_chat_projects',
        HEARTBEAT_INTERVAL: 60000, // 60 seconds
        HEARTBEAT_MESSAGE: 'respond "k"',
        OVERALL_TIMEOUT: 10 * 60 * 1000, // 10 minutes
        POLLING_INTERVAL: 1000, // 1 second
        SESSION_ID: '11111111111111111111', // 20 ones
        NEW_CHAT_ENDPOINT: '/api/v1/chats/new',
        GET_CHAT_ENDPOINT: '/api/v1/chats/',
        COMPLETIONS_ENDPOINT: '/api/chat/completions',
        
        APP_ENDPOINTS: [
            '/api/v1/chats/new',
            '/api/v1/chats/',
            '/api/chat/completions'
        ]
    };

})();

// ===== fetch-blocker.js =====
(function() {
    'use strict';

    window.StreamingChatFetchBlocker = {
        enable: () => {
            const originalFetch = window.fetch;
            const Logger = window.StreamingChatLogger;
            const Config = window.StreamingChatConfig;
            
            window.fetch = function(url, options = {}) {
                // Check if this request is from our app
                const isAppRequest = Config.APP_ENDPOINTS.some(endpoint => {
                    if (typeof url === 'string') {
                        return url.includes(endpoint);
                    } else if (url && url.href) {
                        return url.href.includes(endpoint);
                    }
                    return false;
                });
                
                if (isAppRequest) {
                    Logger.log('FetchBlock', 'Allowing app request', { url: url.toString() });
                    return originalFetch.call(this, url, options);
                } else {
                    Logger.log('FetchBlock', 'Blocking non-app request', { url: url.toString() });
                    // Return a rejected promise to block the request
                    return Promise.reject(new Error('Request blocked: not from streaming chat app'));
                }
            };
            
            Logger.log('FetchBlock', 'Fetch blocking enabled - only app requests allowed');
        }
    };

})();

// ===== file-system.js =====
(function() {
    'use strict';

    class FileSystemManager {
        constructor() {
            this.logger = window.StreamingChatLogger;
            this.logger.log('FileSystem', 'Initializing File System Manager');
        }

        getFileKey(projectId, filePath) {
            // Clean the path to ensure consistency
            const cleanPath = filePath.startsWith('/') ? filePath.substring(1) : filePath;
            return `file-system.${projectId}.${cleanPath}`;
        }

        writeFile(projectId, filePath, content) {
            try {
                const key = this.getFileKey(projectId, filePath);
                localStorage.setItem(key, content);
                this.logger.log('FileSystem', 'File written', { projectId, filePath, size: content.length });
                return true;
            } catch (error) {
                this.logger.error('FileSystem', 'Failed to write file', error);
                return false;
            }
        }

        readFile(projectId, filePath) {
            try {
                const key = this.getFileKey(projectId, filePath);
                const content = localStorage.getItem(key);
                this.logger.log('FileSystem', 'File read', { projectId, filePath, found: !!content });
                return content;
            } catch (error) {
                this.logger.error('FileSystem', 'Failed to read file', error);
                return null;
            }
        }

        deleteFile(projectId, filePath) {
            try {
                const key = this.getFileKey(projectId, filePath);
                localStorage.removeItem(key);
                this.logger.log('FileSystem', 'File deleted', { projectId, filePath });
                return true;
            } catch (error) {
                this.logger.error('FileSystem', 'Failed to delete file', error);
                return false;
            }
        }

        listFiles(projectId) {
            try {
                const prefix = `file-system.${projectId}.`;
                const files = [];

                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith(prefix)) {
                        const filePath = key.substring(prefix.length);
                        files.push('/' + filePath);
                    }
                }

                this.logger.log('FileSystem', 'Files listed', { projectId, count: files.length });
                return files.sort();
            } catch (error) {
                this.logger.error('FileSystem', 'Failed to list files', error);
                return [];
            }
        }

        searchFiles(projectId, query) {
            try {
                const results = [];
                const files = this.listFiles(projectId);

                files.forEach(filePath => {
                    const content = this.readFile(projectId, filePath);
                    if (content && content.toLowerCase().includes(query.toLowerCase())) {
                        const lines = content.split('\n');
                        const matchingLines = [];

                        lines.forEach((line, index) => {
                            if (line.toLowerCase().includes(query.toLowerCase())) {
                                matchingLines.push({
                                    line_number: index + 1,
                                    content: line.trim()
                                });
                            }
                        });

                        if (matchingLines.length > 0) {
                            results.push({
                                file_path: filePath,
                                matches: matchingLines
                            });
                        }
                    }
                });

                this.logger.log('FileSystem', 'Search completed', { 
                    projectId, 
                    query, 
                    filesSearched: files.length, 
                    filesWithMatches: results.length 
                });
                
                return results;
            } catch (error) {
                this.logger.error('FileSystem', 'Search failed', error);
                return [];
            }
        }
    }

    window.StreamingChatFileSystem = FileSystemManager;

})();

// ===== logger.js =====
(function() {
    'use strict';

    window.StreamingChatLogger = {
        log: (category, message, data = null) => {
            const timestamp = new Date().toISOString();
            const logMessage = `[${timestamp}] [${category}] ${message}`;
            console.log(logMessage, data || '');
        },
        error: (category, message, error = null) => {
            const timestamp = new Date().toISOString();
            const logMessage = `[${timestamp}] [${category}] ERROR: ${message}`;
            console.error(logMessage, error || '');
        },
        warn: (category, message, data = null) => {
            const timestamp = new Date().toISOString();
            const logMessage = `[${timestamp}] [${category}] WARNING: ${message}`;
            console.warn(logMessage, data || '');
        }
    };

})();

// ===== project-manager.js =====
(function() {
    'use strict';

    class ProjectManager {
        constructor() {
            this.logger = window.StreamingChatLogger;
            this.config = window.StreamingChatConfig;
            this.utils = window.StreamingChatUtils;
            this.logger.log('ProjectManager', 'Initializing Project Manager');
        }

        saveProjects(projects) {
            try {
                localStorage.setItem(this.config.PROJECTS_KEY, JSON.stringify(projects));
                return true;
            } catch (error) {
                this.logger.error('ProjectManager', 'Failed to save projects', error);
                return false;
            }
        }

        loadProjects() {
            try {
                const data = localStorage.getItem(this.config.PROJECTS_KEY);
                return data ? JSON.parse(data) : [];
            } catch (error) {
                this.logger.error('ProjectManager', 'Failed to load projects', error);
                return [];
            }
        }

        createProject(name) {
            const projects = this.loadProjects();
            const project = {
                id: this.utils.generateUUID(),
                name: name,
                created: Date.now(),
                files: []
            };

            projects.push(project);
            this.saveProjects(projects);

            this.logger.log('ProjectManager', 'Project created', { 
                id: project.id, 
                name: project.name 
            });

            return project;
        }

        getProject(id) {
            const projects = this.loadProjects();
            return projects.find(p => p.id === id);
        }

        listProjects() {
            return this.loadProjects();
        }

        deleteProject(id) {
            const projects = this.loadProjects();
            const index = projects.findIndex(p => p.id === id);
            
            if (index !== -1) {
                const project = projects[index];
                projects.splice(index, 1);
                this.saveProjects(projects);

                this.logger.log('ProjectManager', 'Project deleted', { 
                    id: project.id, 
                    name: project.name 
                });

                return true;
            }

            return false;
        }

        updateProject(id, updates) {
            const projects = this.loadProjects();
            const project = projects.find(p => p.id === id);
            
            if (project) {
                Object.assign(project, updates);
                this.saveProjects(projects);

                this.logger.log('ProjectManager', 'Project updated', { 
                    id: project.id, 
                    updates 
                });

                return project;
            }

            return null;
        }
    }

    window.StreamingChatProjectManager = ProjectManager;

})();

// ===== streaming-parser.js =====
(function() {
    'use strict';

    class StreamingParser {
        constructor() {
            this.logger = window.StreamingChatLogger;
            this.buffer = '';
            this.completeOutput = '';
            this.toolUses = [];
            this.logger.log('StreamingParser', 'Initializing Streaming Parser');
        }

        reset() {
            this.buffer = '';
            this.completeOutput = '';
            this.toolUses = [];
            this.logger.log('StreamingParser', 'Parser reset');
        }

        processChunk(chunk) {
            this.buffer += chunk;
            this.completeOutput += chunk;

            const parseResult = {
                displayText: chunk,
                toolUses: []
            };

            // Look for complete tool use patterns in the buffer
            const toolUseRegex = /<tool_use>(\{[^}]*\})<\/tool_use>/g;
            let match;
            let lastIndex = 0;
            let bufferModified = false;

            while ((match = toolUseRegex.exec(this.buffer)) !== null) {
                try {
                    const toolData = JSON.parse(match[1]);
                    this.toolUses.push({
                        fullMatch: match[0],
                        data: toolData,
                        position: match.index
                    });

                    parseResult.toolUses.push({
                        fullMatch: match[0],
                        data: toolData
                    });

                    bufferModified = true;
                } catch (e) {
                    this.logger.warn('StreamingParser', 'Failed to parse tool JSON', { 
                        json: match[1] 
                    });
                }
            }

            // Remove processed tool uses from display text
            if (bufferModified) {
                let cleanChunk = chunk;
                parseResult.toolUses.forEach(toolUse => {
                    cleanChunk = cleanChunk.replace(toolUse.fullMatch, '');
                });
                parseResult.displayText = cleanChunk;
            }

            return parseResult;
        }

        getToolUses() {
            return this.toolUses.map(tu => tu);
        }

        getCompleteOutput() {
            // Return output with tool use tags removed
            let cleanOutput = this.completeOutput;
            this.toolUses.forEach(toolUse => {
                cleanOutput = cleanOutput.replace(toolUse.fullMatch, '');
            });
            return cleanOutput;
        }
    }

    window.StreamingChatParser = StreamingParser;

})();

// ===== tool-manager.js =====
(function() {
    'use strict';

    class ToolManager {
        constructor(fileSystem) {
            this.logger = window.StreamingChatLogger;
            this.fileSystem = fileSystem;
            this.activeProjects = [];
            this.logger.log('ToolManager', 'Initializing Tool Manager');
        }

        setActiveProjects(projectIds) {
            this.activeProjects = Array.isArray(projectIds) ? projectIds : [projectIds];
            this.logger.log('ToolManager', 'Active projects updated', { 
                activeProjects: this.activeProjects 
            });
        }

        async executeTool(toolData) {
            this.logger.log('ToolManager', 'Executing tool', { 
                tool_type: toolData.tool_type,
                activeProjects: this.activeProjects 
            });

            try {
                switch (toolData.tool_type) {
                    case 'read_file':
                        return await this.executeReadFile(toolData);
                    case 'search_files':
                        return await this.executeSearchFiles(toolData);
                    default:
                        throw new Error(`Unknown tool type: ${toolData.tool_type}`);
                }
            } catch (error) {
                this.logger.error('ToolManager', 'Tool execution failed', error);
                return {
                    tool_type: toolData.tool_type,
                    error: error.message,
                    results: []
                };
            }
        }

        async executeReadFile(toolData) {
            const results = [];

            if (!toolData.file_path) {
                throw new Error('file_path is required for read_file tool');
            }

            for (const projectId of this.activeProjects) {
                const content = this.fileSystem.readFile(projectId, toolData.file_path);
                
                if (content !== null) {
                    results.push({
                        project_id: projectId,
                        file_path: toolData.file_path,
                        content: content,
                        size: content.length
                    });
                } else {
                    results.push({
                        project_id: projectId,
                        file_path: toolData.file_path,
                        error: 'File not found'
                    });
                }
            }

            return {
                tool_type: 'read_file',
                file_path: toolData.file_path,
                results: results
            };
        }

        async executeSearchFiles(toolData) {
            const results = [];

            if (!toolData.query) {
                throw new Error('query is required for search_files tool');
            }

            for (const projectId of this.activeProjects) {
                const searchResults = this.fileSystem.searchFiles(projectId, toolData.query);
                
                if (searchResults.length > 0) {
                    results.push({
                        project_id: projectId,
                        query: toolData.query,
                        matches: searchResults
                    });
                } else {
                    results.push({
                        project_id: projectId,
                        query: toolData.query,
                        matches: []
                    });
                }
            }

            return {
                tool_type: 'search_files',
                query: toolData.query,
                results: results
            };
        }
    }

    window.StreamingChatToolManager = ToolManager;

})();

// ===== ui-builder.js =====
(function() {
    'use strict';

    window.StreamingChatUIBuilder = {
        createHTML: () => {
            return `
                <div class="streaming-chat-ide">
                    <div class="left-panel">
                        <div class="project-selector">
                            <select id="project-dropdown">
                                <option value="">Select Project...</option>
                                <option value="__new__">+ Create New Project</option>
                            </select>
                        </div>
                        
                        <div class="file-explorer" id="file-explorer">
                            <div class="no-project">Select a project to view files</div>
                        </div>
                    </div>
                    
                    <div class="right-panel">
                        <div class="editor-tabs" id="editor-tabs">
                            <div class="editor-tab chat-tab active" data-tab="chat">
                                💬 Chat
                            </div>
                        </div>
                        
                        <div class="editor-content" id="editor-content">
                            <div class="tab-pane chat-container active" data-tab="chat">
                                <div class="messages" id="messages-streaming"></div>
                                
                                <div class="input-container">
                                    <div class="status-bar" id="status-streaming">Ready</div>
                                    <div class="input-wrapper">
                                        <textarea id="user-input-streaming" 
                                                placeholder="Type your message... (Shift+Enter for new line, Enter to send)"
                                                rows="3"></textarea>
                                        <button id="send-btn-streaming" class="btn btn-primary">Send</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        },

        createCSS: () => {
            return `
                * {
                    margin: 0;
                    padding: 0;
                    box-sizing: border-box;
                }

                body {
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                    background: #1a1a1a;
                    color: #e0e0e0;
                    height: 100vh;
                    overflow: hidden;
                }

                .streaming-chat-ide {
                    display: flex;
                    height: 100vh;
                    background: #1a1a1a;
                }

                .left-panel {
                    width: 300px;
                    background: #252525;
                    border-right: 1px solid #444;
                    display: flex;
                    flex-direction: column;
                }

                .right-panel {
                    flex: 1;
                    display: flex;
                    flex-direction: column;
                }

                .project-selector {
                    padding: 15px;
                    border-bottom: 1px solid #444;
                }

                #project-dropdown {
                    width: 100%;
                    background: #333;
                    border: 1px solid #555;
                    color: #e0e0e0;
                    padding: 8px 12px;
                    border-radius: 4px;
                    font-size: 13px;
                }

                .file-explorer {
                    flex: 1;
                    overflow-y: auto;
                    padding: 15px;
                    position: relative;
                }

                .no-project {
                    color: #666;
                    text-align: center;
                    margin-top: 50px;
                    font-size: 14px;
                }

                .file-tree {
                    font-size: 13px;
                }

                .file-item, .folder-item {
                    padding: 4px 8px;
                    cursor: pointer;
                    border-radius: 3px;
                    margin: 1px 0;
                }

                .file-item:hover, .folder-item:hover {
                    background: #333;
                }

                .folder-item {
                    font-weight: 500;
                }

                .folder-icon {
                    display: inline-block;
                    margin-right: 6px;
                    transition: transform 0.2s;
                }

                .folder-item.expanded .folder-icon {
                    transform: rotate(90deg);
                }

                .editor-tabs {
                    background: #2d2d2d;
                    border-bottom: 1px solid #444;
                    display: flex;
                    align-items: center;
                    min-height: 40px;
                    overflow-x: auto;
                }

                .editor-tab {
                    padding: 8px 16px;
                    background: #333;
                    border-right: 1px solid #444;
                    cursor: pointer;
                    font-size: 13px;
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    white-space: nowrap;
                    position: relative;
                }

                .editor-tab:hover {
                    background: #404040;
                }

                .editor-tab.active {
                    background: #1a1a1a;
                    border-bottom: 2px solid #0d7377;
                }

                .editor-tab .close-btn {
                    background: none;
                    border: none;
                    color: #aaa;
                    cursor: pointer;
                    padding: 0;
                    width: 16px;
                    height: 16px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    border-radius: 2px;
                    font-size: 14px;
                    line-height: 1;
                }

                .editor-tab .close-btn:hover {
                    background: #555;
                    color: white;
                }

                .editor-content {
                    flex: 1;
                    background: #1a1a1a;
                    overflow: hidden;
                    position: relative;
                }

                .tab-pane {
                    display: none;
                    height: 100%;
                    flex-direction: column;
                }

                .tab-pane.active {
                    display: flex;
                }

                .chat-container {
                    display: flex;
                    flex-direction: column;
                    height: 100%;
                }

                .file-editor-pane {
                    display: flex;
                    flex-direction: column;
                    height: 100%;
                }

                .file-editor-content {
                    flex: 1;
                    overflow: hidden;
                    position: relative;
                }

                .editor-textarea {
                    width: 100%;
                    height: 100%;
                    background: #1a1a1a;
                    border: none;
                    color: #e0e0e0;
                    font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
                    font-size: 13px;
                    line-height: 1.4;
                    resize: none;
                    outline: none;
                    padding: 15px;
                    margin: 0;
                }

                .file-actions {
                    background: #2d2d2d;
                    border-bottom: 1px solid #444;
                    padding: 8px 15px;
                    display: flex;
                    gap: 10px;
                    align-items: center;
                }

                .file-actions .btn {
                    padding: 4px 8px;
                    font-size: 11px;
                }

                .file-path {
                    flex: 1;
                    font-family: monospace;
                    font-size: 12px;
                    color: #aaa;
                }

                .new-file-btn {
                    position: absolute;
                    top: 10px;
                    right: 10px;
                    background: #0d7377;
                    border: none;
                    color: white;
                    width: 24px;
                    height: 24px;
                    border-radius: 50%;
                    cursor: pointer;
                    font-size: 14px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                }

                .new-file-btn:hover {
                    background: #0a5d61;
                }

                .messages {
                    flex: 1;
                    overflow-y: auto;
                    padding: 20px;
                    display: flex;
                    flex-direction: column;
                    gap: 15px;
                }

                .message {
                    max-width: 80%;
                    padding: 12px 16px;
                    border-radius: 8px;
                    white-space: pre-wrap;
                    word-wrap: break-word;
                }

                .message.user {
                    align-self: flex-end;
                    background: #0d7377;
                    border: 1px solid #14a085;
                }

                .message.assistant {
                    align-self: flex-start;
                    background: #2d2d2d;
                    border: 1px solid #444;
                }

                .message.streaming {
                    border-left: 3px solid #ffa726;
                }

                .message.progress {
                    border-left: 3px solid #2196f3;
                    padding: 8px 16px;
                    min-height: 20px;
                    display: flex;
                    align-items: center;
                }

                .progress-bar-container {
                    width: 100%;
                    height: 8px;
                    background: #444;
                    border-radius: 4px;
                    overflow: hidden;
                }

                .progress-bar-fill {
                    height: 100%;
                    background: linear-gradient(90deg, #2196f3, #64b5f6);
                    border-radius: 4px;
                    transition: width 0.3s ease;
                }

                .message.tool-result {
                    border-left: 3px solid #9c27b0;
                    background: #2a2a2a;
                    cursor: pointer;
                    transition: background-color 0.2s;
                }

                .message.tool-result:hover {
                    background: #333;
                }

                .tool-use-indicator {
                    display: inline-flex;
                    align-items: center;
                    gap: 8px;
                    background: #3a3a3a;
                    border: 1px solid #555;
                    border-radius: 4px;
                    padding: 4px 8px;
                    margin: 2px 4px;
                    cursor: pointer;
                    transition: background-color 0.2s;
                }

                .tool-use-indicator:hover {
                    background: #444;
                }

                .tool-icon {
                    font-size: 14px;
                }

                .tool-main {
                    font-size: 12px;
                    color: #ccc;
                    font-family: monospace;
                }

                .tool-header {
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    margin-bottom: 8px;
                    font-weight: bold;
                }

                .tool-title {
                    color: #e0e0e0;
                }

                .tool-preview {
                    font-size: 12px;
                    color: #aaa;
                    white-space: pre-line;
                }

                .input-container {
                    border-top: 1px solid #444;
                    background: #252525;
                }

                .status-bar {
                    padding: 6px 20px;
                    font-size: 12px;
                    border-bottom: 1px solid #444;
                    background: #2d2d2d;
                }

                .status-bar.ready { color: #4caf50; }
                .status-bar.error { color: #f44336; }
                .status-bar.streaming { color: #ffa726; }
                .status-bar.success { color: #4caf50; }

                .input-wrapper {
                    display: flex;
                    padding: 15px 20px;
                    gap: 10px;
                    align-items: flex-end;
                }

                #user-input-streaming {
                    flex: 1;
                    background: #333;
                    border: 1px solid #555;
                    color: #e0e0e0;
                    padding: 10px 12px;
                    border-radius: 4px;
                    resize: vertical;
                    min-height: 40px;
                    max-height: 120px;
                    font-family: inherit;
                    font-size: 14px;
                    line-height: 1.4;
                }

                #user-input-streaming:focus {
                    outline: none;
                    border-color: #0d7377;
                }

                .btn {
                    background: #0d7377;
                    border: none;
                    color: white;
                    padding: 10px 20px;
                    border-radius: 4px;
                    cursor: pointer;
                    font-size: 13px;
                    font-weight: 500;
                    transition: background-color 0.2s;
                }

                .btn:hover {
                    background: #0a5d61;
                }

                .btn:disabled {
                    background: #666;
                    cursor: not-allowed;
                }

                .btn-small {
                    padding: 6px 12px;
                    font-size: 11px;
                }

                .btn-primary {
                    background: #0d7377;
                }

                .btn-secondary {
                    background: #666;
                }

                /* Custom scrollbars */
                ::-webkit-scrollbar {
                    width: 8px;
                    height: 8px;
                }

                ::-webkit-scrollbar-track {
                    background: #2d2d2d;
                }

                ::-webkit-scrollbar-thumb {
                    background: #555;
                    border-radius: 4px;
                }

                ::-webkit-scrollbar-thumb:hover {
                    background: #666;
                }
            `;
        },

        replacePageContent: () => {
            const Logger = window.StreamingChatLogger;
            Logger.log('UI', 'Completely replacing page content');
            
            // Clear entire page
            document.head.innerHTML = '';
            document.body.innerHTML = '';
            
            // Add basic meta tags
            const meta = document.createElement('meta');
            meta.setAttribute('charset', 'UTF-8');
            document.head.appendChild(meta);
            
            const viewport = document.createElement('meta');
            viewport.setAttribute('name', 'viewport');
            viewport.setAttribute('content', 'width=device-width, initial-scale=1.0');
            document.head.appendChild(viewport);
            
            // Add title
            const title = document.createElement('title');
            title.textContent = 'AI Chat Streaming IDE';
            document.head.appendChild(title);
            
            // Add CSS
            const style = document.createElement('style');
            style.textContent = window.StreamingChatUIBuilder.createCSS();
            document.head.appendChild(style);
            
            // Set body HTML
            document.body.innerHTML = window.StreamingChatUIBuilder.createHTML();
            
            Logger.log('UI', 'Page content replaced successfully');
            return document.body;
        }
    };

})();

// ===== utils.js =====
(function() {
    'use strict';

    window.StreamingChatUtils = {
        generateUUID: () => {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        },
        
        get13DigitTimestamp: () => {
            return Date.now();
        },
        
        get10DigitTimestamp: () => {
            return Math.floor(Date.now() / 1000);
        }
    };

})();

// ===== zz-app-starter.js (INITIALIZATION) =====
(function() {
    'use strict';

    // Wait for DOM to be ready
    function initializeApp() {
        const Logger = window.StreamingChatLogger;
        Logger.log('Main', 'Loading Streaming AI Chat Overlay');
        
        try {
            const app = new window.StreamingChatApp();
            app.init();
            
            // Expose to window for debugging and external access
            window.aiChatOverlayStreaming = app;
            
            Logger.log('Main', 'Streaming AI Chat Overlay loaded successfully');
            console.log('Streaming AI Chat Overlay loaded! Access via window.aiChatOverlayStreaming');
            
        } catch (error) {
            Logger.error('Main', 'Failed to initialize app', error);
            console.error('Failed to initialize Streaming AI Chat Overlay:', error);
        }
    }

    // Initialize immediately since we're replacing the entire page
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeApp);
    } else {
        initializeApp();
    }

})();
